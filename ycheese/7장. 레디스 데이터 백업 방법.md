# 7장. 레디스 데이터 백업 방법

> 레디스의 모든 데이터는 메모리에서 관리되기 때문에 장애로 인해 재시작될 경우 메모리에 상주한 데이터들이 손실될 가능성이 있습니다. 이를 백업할 수 있는 방법에 대해 알아봅시다.
> 

# 백업 vs 복제

🙋🏻‍♂️ : 복제 구조로 사용하면 데이터 백업 필요없지 않나요?

**백업과 복제는 목적부터 다르다 !**

- **백업**: 장애 상황에서 데이터 복구를 위해
- **복제**: 가용성을 위해

마스터 노드에서 의도하지 않은 데이터 삭제 커맨드 실행 시 바로 복제본에 전달되기 때문에 복제 구조로는 데이터를 안전하게 유지할 수 없다.

# 데이터 백업 in Redis

## RDB vs AOF(Append-Only File)

레디스가 지원하는 백업 방식에는 RDB와 AOF가 있다.

### RDB

일정 시점에 메모리에 저장된 데이터 전체를 저장 (**스냅샷** 방식)

- 시점 단위로 여러 백업본을 저장할 수 있음
- AOF보다 복원이 빠름
- 특정 시점으로의 복구가 불가능
- 손실 가능성을 최소화해야 하는 서비스에서 적절하지 않음

### AOF

레디스 인스턴스가 처리한 모든 쓰기 작업을 **차례대로 기록**

- RDB 파일보다 크기가 큼
- 주기적으로 압축해 재작성해야 함
- 원하는 시점으로 복구 가능

### 🤔 뭘 쓸까 ?

- 하나의 인스턴스에서 RDB, AOF 옵션을 `동시에` 사용하는 것이 가능하다.
- 일반적인 RDB 만큼의 **데이터 안정성**을 원한다면 두 가지 백업 방식을 **동시에** 사용하는 것을 권장한다.

## ⚠️ 주의 사항

- 레디스는 서버가 재시작 될 때에만 데이터를 복원할 수 있다.
- 복원 시점에 RDB/AOF 파일이 모두 존재하면 AOF 데이터를 로드한다.
    - AOF 파일이 더 내구성이 보장된다고 판단하기 때문
    > **🔍 왜 AOF 파일이 더 내구성이 보장되는가 ?**
    >- 변경 작업을 지속적으로 기록하므로 시스템 중단시에도 최신 변경 내역을 보존함
    >- 읽기 쉽고 수동으로 파일 수정이 가능
    >- 옵션이 유연함

# RDB 방식의 데이터 백업

## RDB 파일 생성하기

### 1. 특정 조건에 자동 RDB 파일 생성 설정

```powershell
save <기간(초)> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름(default: dump.rdb)>
dir <RDB 파일이 저장될 경로>
```

일정한 기간동안 변경된 키의 개수가 조건에 맞을 때 자동으로 RDB 파일을 생성하는 방식

```powershell
# 900초(15분) 동안 1개 이상의 키 변경시 파일 생성
save 900 1
# 300초(5분) 동안 10개 이상의 키 변경시 파일 생성
save 300 10
# 60초(1분) 동안 10000개 이상의 키 변경시 파일 생성
save 60 10000

# 현재 적용된 save 옵션 확인
> CONFIG GET save
1) "save"
2) "900 1 300 10 60 10000"

# save 옵션 초기화
> CONFIG SET save ""
OK

# redis.conf 파일 재작성
> CONFIG REWRITE
OK
```

**🤔 CONFIG REWRITE**

- 레디스 인스턴스가 실행 중인 상태에서 설정 파일을 변경하는 것은 반영되지 않는다.
- `CONFIG REWRITE` 커맨드를 이용해 설정 파일을 재작성하는 과정을 거쳐야 한다.
- `CONFIG REWRITE` 없이 인스턴스가 재시작되면 변경되지 않은 옵션 값으로 돌아간다.

### 2. 사용자가 원하는 시점에 수동으로 생성

**SAVE**

- **동기 방식**으로 파일 저장
    - 생성이 완료될 때까지 다른 모든 클라이언트의 명령이 차단됨
    - 일반적인 운영 환경에서는 사용 권장 ❌

**BGSAVE**

- fork를 호출해 자식 프로세스를 생성하여 **백그라운드에서 생성**
- 이미 백그라운드로 데이터가 저장되고 있다면 에러를 반환
    - `SCHEDULE` 옵션 사용 시 기존에 진행 중이던 백업 완료 후 BGSAVE 재실행

정상적으로 저장됐는지 여부를 `LASTSAVE` 커맨드를 통해 확인할 수 있다. (파일 저장 시점 유닉스 타임스탬프로 반환)

### 3. 복제 기능 사용 시 자동 RDB 파일 생성

🙋🏻‍♂️**복제본**: `REPLICAOF` !

💁🏻‍♀️**마스터 노드**: 🎁 (RDB 파일)

**복제본의 REPLICAOF 요청이 발생하는 경우**

- 최초 복제 연결 시
- 복제 재연결 발생 시 : 네트워크 이슈로 복제가 끊어졌다가 복구된 경우

# AOF 방식의 데이터 백업

## AOF 파일 생성하기

설정 파일에서 appendonly 옵션을 yes로 설정한다.

```powershell
appendonly yes
appendfilename "backup.aof" # aof 파일 이름 (default appendonly.aof)
appenddirname "backupdir"   # aof 파일 저장 경로
```

- 7.0 버전 이상부터 AOF 파일은 여러 개로 저장됨
- `appenddirname` 옵션은 디렉터리 이름만 지정 가능(경로 X), dir 옵션 하위에 생성
- 메모리 상 변경되는 커맨드만 기록됨
- 모든 커맨드의 실행 내역은 레디스 프로토콜(RESP) 형식으로 저장됨
- 항상 사용자가 실행한 커맨드를 그대로 저장하지는 않음
    - 블로킹 기능을 지원하는 커맨드는 굳이 명시해줄 필요가 없음 (BRPOP → RPOP)
    - 부동소수점을 처리하는 방식은 레디스 실행 아키텍처에 따라 다를 수 있어 증분 후 값을 직접 SET하는 커맨드로 변경해서 저장

## AOF 파일 재구성하기

실행되는 시간에 비례해서 AOF 파일의 크기가 계속 증가함 → **주기적인 압축 필요 (재구성)**

### 재구성 원리

레디스 메모리에 있는 데이터를 읽어와서 새로운 파일로 저장하는 형태로 동작

기본 옵션(`aof-use-rdb-preamble yes`)을 no로 변경하지 않으면 RDB 파일 형태로 저장

- no로 변경 시 `*.base.aof` 이름의 RESP 프로토콜 형태의 텍스트로 변경된다.

`fork`를 이용해 자식 프로세스를 생성하여 AOF 파일을 재구성해 저장하는 방식

### 버전 7 이전

AOF 파일의 **앞부분**은 바이너리 형태의 RDB 파일, **뒷부분**은 RESP 형태의 커맨드 로그

**재구성 과정**

1. 레디스는 fork를 이용해 자식 프로세스를 생성한다.
2. 생성된 자식 프로세스는 레디스의 메모리를 읽어와 신규 생성한 임시 파일에 저장한다.
3. 그동안 변경된 내역은 기존의 AOF 파일과 인메모리 버퍼에 **동시에** 저장된다.
4. AOF 재구성 과정이 끝나면 인메모리 버퍼에 저장된 내용을 임시 파일 마지막에 추가한다.
5. 생성된 임시 파일로 기존 AOF 파일을 덮어 씌운다.

**단점**

- 재구성을 진행하는 동안 동일한 로그가 AOF 파일과 인메모리 버퍼에 이중 저장됨
- 하나의 AOF 파일 내 바이너리 형태와 RESP 형태의 데이터가 혼재함
    - 수동으로 AOF 파일 처리가 복잡함

### 버전 7 이후

RDB 파일과 AOF 파일을 **나눠 관리**, 매니페스트 파일을 추가하여 각 파일의 정보를 담음

**재구성 과정**

1. 레디스는 fork를 이용해 자식 프로세스를 생성한다.
2. 생성된 자식 프로세스는 레디스의 메모리를 읽어와 신규 생성한 임시 파일에 저장한다.
3. 그동안 변경된 내역은 신규 AOF 파일에 저장된다.
4. AOF 재구성 과정이 끝나면 임시 매니페스트 파일을 생성해서 변경된 버전으로 파일 내용을 업데이트한다.
    - RDB, AOF 파일 명의 번호와 매니페스트 파일의 seq 값을 1씩 증가시킨다.
5. 생성된 임시 매니페스트 파일로 기존 매니페스트 파일을 덮어 씌운 뒤 이전 버전의 AOF, RDB 파일들을 삭제한다.

🙂 훨씬 간단한 과정으로 데이터를 효율적으로 저장할 수 있다 -!

## 자동 AOF 재구성

```powershell
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

- **auto-aof-rewrite-percentage**: 마지막으로 재구성된 AOF 파일의 크기와 비교해 현재 파일이 지정된 퍼센트만큼 커지면 재구성을 시도
- **auto-aof-rewrite-min-size**: 현재 AOF 파일이 지정된 크기만큼 커지면 재구성을 시도
- `percentage`가 우선이되, 비효율적으로 동작할 수 있으므로 `min-size`를 지정하여 최소값을 설정한다.

```powershell
# 마지막으로 재구성된 AOF 파일 크기 확인
> INFO Persistence
# Persistence
...
aof_current_size:186830
aof_base_size:145802    # 마지막으로 저장된 AOF 파일 크기
```

레디스 인스턴스가 처음 부팅되면 `aof_base_size`가 0이므로 이때는 `auto-aof-rewrite-min-size`를 기준으로 데이터가 재구성된다.

## 수동 AOF 재구성

`BGREWRITEAOF`: 직접 AOF 파일을 재구성한다. 자동 재구성과 동일하게 동작한다.

### AOF 타임스탬프

버전 7 이상부터 AOF를 저장할 때 타임스탬프를 남길 수 있다.

```powershell
# 활성화시키면 AOF 데이터가 저장될 때 타임스탬프도 함께 저장된다.
aof-timestamp-enabled yes
```

**🤔 왜 쓰나?**

- 수동으로 AOF 파일을 조작하지 않아도 시스템 상에서 **시점 복원**이 가능
    
    ```powershell
    $ src/redis-check-aof --truncate-to-timestamp 1669532844 appendonlydir/appendonly.aof.manifest
    ```
    
    `truncate-to-timestamp` 옵션으로 AOF 파일을 복구하면 **원본 파일이 변경**되므로 이전 파일을 보호하고 싶다면 미리 복사해두자.
    

## AOF 파일 복원

AOF 파일 작성 중 서버 장애가 발생했다면? **시점 복원**을 통해 확인할 수 있다 !

```powershell
# 확인 커맨드
$ src/redis/check-aof appendonlydir/appendonly.aof.manifest
# RDB 파일은 정상, AOF 파일은 비정상인 경우
...
[offset 169912] Checksum OK
[offset 169912] \o/ RDB looks OK! \o/
...
AOF appendonly.aof.15.incr.aof is not valid.
Use the --fix option to try fixing it.

# fix 옵션으로 해결
$ src/redis-check-aof --fix appendonlydir/appendonly.aof.manifest
...
Successfully truncated AOF appendonly.aof.15.incr.aof
All AOF files and manifest are valid
```

`fix` 옵션 역시 **원본 파일이 변경**되므로 이전 파일을 보호하고 싶다면 미리 복사해두자.

# AOF 파일은 얼마나 안전한가?

레디스에서 AOF 파일을 저장할 때 `APPENDFSYNC` 옵션을 이용하면 **FSYNC 호출을 제어**할 수 있다.

**🤔 FSYNC 호출이란?**

- 운영체제에서 애플리케이션이 파일에 데이터를 저장하려고 하면 곧바로 저장하지 않는다.
- WRITE 시스템 콜을 이용해 저장을 요청하면 커널 영역의 OS 버퍼에 데이터를 임시로 저장한다.
- 운영체제 판단에 커널이 여유있거나 최대 지연 시간(30초)에 도달하면 데이터를 실제로 디스크에 쓴다.
- FSYNC는 이를 디스크에 내리도록 강제하는 시스템 콜이다.

## APPENDFSYNC 옵션

- **APPENDFSYNC no**
    - 데이터 저장 시 WRITE 시스템 콜 호출
    - 커널 영역에 데이터가 저장됐는지만 확인 → 쓰기 성능 가장 좋음
- **APPENDFSYNC always**
    - 데이터 저장 시 항상 WRITE, FSYNC 시스템 콜 함께 호출
    - 매번 데이터가 파일에 정확하게 저장되는 것을 기다림 → 쓰기 성능 가장 나쁨
- **(default) APPENDFSYNC everysec**
    - 데이터 저장 시 WRITE 시스템 콜 호출 + 1초마다 FSYNC 시스템 콜 호출
    - 성능은 no와 거의 비슷함
    - 성능이 좋고 속도-안정성 균형을 맞출 수 있다. (권장)

# 백업을 사용할 때 주의할 점

1. 인스턴스의 `maxmemory` 값은 실제 서버 메모리보다 여유를 갖고 설정하자.
    - BGSAVE로 백업 진행 시 fork()로 자식 프로세스를 생성해 메모리 상의 데이터를 하나 더 복사하는 방법으로 이루어진다.
    - 물리적 메모리에 있는 실제 메모뢰 페이지가 그대로 복제되어 **최악의 경우 기존 메모리 용량의 2배를 사용**할 수 있다.
    - `**maxmemory`를 너무 크게 설정하면 `copy-on-write` 동작으로 인해 `OOM`이 일어날 수 있다.**
    
    **RAM 크기 별 maxmemory 권장값**
   
    ~~GPT는 절반 정도가 합리적이래요 …~~
    
    | RAM | Maxmemory | 비율 |
    | --- | --- | --- |
    | 2GB | 638MB | 33% |
    | 4GB | 2048MB | 50% |
    | 8GB | 4779MB | 58% |
    | 16GB | 10240MB | 63% |
    | 32GB | 21163MB | 65% |
    | 64GB | 43008MB | 66% |
3. RDB 스냅샷 저장 도중에는 AOF 재구성 기능을 사용할 수 없다.
    - AOF 재구성이 진행되면 BGSAVE를 실행할 수 없다.
    
    **→ RDB와 AOF 재구성은 동시에 이루어질 수 없다.**
