# 8장. 복제

> 레디스의 가용성을 책임지는 복제 기능! 그리고 백업과의 연관 관계를 알아봅시다.
> 

# 가용성

일정 시간 동안 서비스를 정상적으로 사용할 수 있는 시간의 비율

## 레디스에서 고가용성 확보하기

### ⭐️ 복제

- 마스터 노드의 **데이터를 복제본 노드로 실시간 복사**하는 기능

- 마스터 노드의 데이터 유실 시 복제본 노드에서 데이터 확인 가능

### 자동 페일오버

- 마스터 노드에서 발생한 장애를 감지해 **클라이언트 연결을 자동으로 복제본 노드로 리디렉션**하는 기능

- 빠른 장애 조치 👌🏻

# 복제 구조

## 왜 쓸까?

- 하드웨어는 언제든지 고장날 수 있으므로 대신 사용할 여분이 필요하다.
- 복제본은 부하 분산으로 마스터 노드의 트래픽을 감소시킬 수 있다.
- 백업을 복제본에서 수행하면 백업 작업이 서비스에 미치는 영향도를 최소화할 수 있다.

## 🤔 멀티 마스터 복제 구조?

모든 노드가 마스터이면서 동시에 복제본이 되는 구조

**레디스에서는 지원하지 않는다.**

- 마스터는 복제본이 될 수 없다.
- 모든 데이터의 입력은 마스터 노드에서 이뤄진다.
- 복제본 노드는 읽기 전용으로 동작한다.

## 복제 구조 구성하기

```powershell
REPLICAOF <master-ip> <master-port>
```

- 마스터에는 여러 개의 복제본이 연결될 수 있다.
- 복제본 노드에 새로운 복제본을 추가할 수 있다.
    - 복제본에 직접 데이터를 쓰더라도(`replica-read-only` 해제 필요) 복제본에 쓰는 내용은 다른 복제본으로 전파되지 않는다.
- 한 개의 복제 그룹에서는 항상 한 개의 마스터 노드만 존재한다.

### 패스워드 설정

- 레디스 6.0부터 기본적인 패스워드를 사용해서 데이터를 복제할 때 `masterauth` 옵션에 패스워드를 입력해야 한다.
    
    ```powershell
    # 설정값 변경
    > CONFIG SET masterauth mypassword
    OK
    
    # 인스턴스 재시작 없이 설정 파일 적용
    > CONFIG REWRITE
    OK
    ```
    
- `requirepass` 옵션을 이용해 설정한 패스워드를 복제본 노드에서 `masterpass` 옵션에 입력해야 한다. **(해당 값이 없으면 마스터에서 데이터를 받아갈 수 없다 !)**
- 하나의 복제 그룹에 속한 마스터와 복제본 노드는 같은 패스워드를 설정하는 것이 일반적이다.

# 복제 메커니즘

## 버전 7 이전

`repl-diskless-sync` 옵션 기본값 **no**

### 수행 과정

1. `REPLICAOF` 커맨드로 복제 연결을 시도한다.
2. 마스터 노드에서 `fork`로 자식 프로세스를 만든다.
3. 자식 프로세스에서 RDB 스냅샷을 생성한다.
4. 그동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜(RESP) 형태로 마스터의 복제 버퍼에 저장된다.
5. RDB 파일이 생성 완료되면 파일을 복제본 노드로 복사한다.
6. 복제본에 저장된 모든 내용을 삭제한 뒤 RDB 파일을 이용해 데이터를 로딩한다.
7. 복제 과정 동안 버퍼링됐던 복제 버퍼의 데이터를 복제본으로 전달해 수행한다.

### 수행 결과

- 마스터 노드는 `BGSAVE` 커맨드를 이용해 디스크에 RDB 파일을 생성한다.
- 복제본 노드는 마스터로부터 RDB 파일을 읽어온다.
- 복제본 노드는 읽어온 RDB 파일을 로드한다.

**→ 복제 속도는 디스크 I/O 처리량에 영향을 받는다.**

## 버전 7 이후

`repl-diskless-sync` 옵션 기본값 **yes**

### 수행 과정

1. `REPLICAOF` 커맨드로 복제 연결을 시도한다.
2. 마스터 노드는 소켓 통신을 이용해 복제본 노드에 연결한다.
3. RDB 파일은 생성과 동시에 점진적으로 복제본의 소켓으로 전송된다.
4. 그동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜(RESP) 형태로 마스터의 복제 버퍼에 저장된다.
5. 소켓에서 읽어온 RDB 파일은 복제본의 디스크에 저장된다.
    - 복제본의 `repl-diskless-load` 옵션 기본값이 **disabled**이기 때문
    - 소켓 통신으로 받아온 데이터가 정상적인지 미리 확인이 어렵기 때문에 데이터의 안정성을 확보하기 위해 디스크에 먼저 데이터를 저장한다고 한다. (?)
6. 복제본에 저장된 모든 내용을 삭제한 뒤 RDB 파일을 이용해 데이터를 로딩한다.
7. 복제 과정 동안 버퍼링됐던 복제 버퍼의 데이터를 복제본으로 전달해 수행한다.

## 비교

- 디스크의 I/O가 느리고 네트워크가 빠른 경우 디스크를 사용하지 않는 복제가 더 빠르다.
- 디스크를 사용하는 복제는 RDB 파일이 생성되는 도중 다른 노드에서 복제 연결 요청이 들어오면 연결을 큐에 저장하고 기존 RDB 파일 저장 완료 후 여러 복제본이 한 번에 복제 연결을 시작할 수 있다.
- 디스크를 사용하지 않는 복제는 복제 과정이 끝나기 전까지 다른 복제본과의 연결을 수행할 수 없다.
    - 네트워크가 유실돼 재동기화 요청 시 마스터에 한 번에 여러 개 복제 연결이 들어올 수 있으므로 repl-diskless-sync-delay 옵션(기본값 5(초))을 사용할 수 있다.

# 복제 연결

- 마스터 → 복제본 데이터 전달은 **비동기 방식으로 동작**한다.
- 복제본에 데이터 전달이 됐는지 확인하지 않기 때문에 `짧은 지연 시간`과 `높은 성능`을 갖는다.
    
    🙋🏻‍♂️: 복제본에 전달하기 전에 마스터가 죽으면 데이터 날리나요?
    
    💁🏻‍♀️: 넹. 복제 속도가 매우 빠르기 때문에 거의 안 그래요.
    
- 모든 레디스 인스턴스는 **복제 ID**와 **오프셋**을 갖는다.
    - 레디스 내부 데이터가 수정되는 모든 커맨드를 수행할 때마다 오프셋이 증가한다.

## 복제 연결 상태 확인

### 마스터

```powershell
> INFO REPLICATION
# Replication
role: master
connected_salves: 2     # 연결된 복제본 수
slave0: ip=127.0.0.1,port=6002,state=online,offset=701,lag=1 # 불일치
slave1: ip=127.0.0.1,port=6003,state=online,offset=709,lag=0 # 정확히 일치
master_replid: e3b07d3eba52283842a2403aa3823489a
master_repl_offset: 709 # 현재 오프셋
...
```

- 연결된 복제본 수와 복제본 정보 확인 가능
- 복제본 offset을 통해 마스터와 일치 여부 확인 가능
    - **복제 id와 오프셋이 같을 때 두 노드가 정확히 일치하다는 것을 의미**

### 복제본

```powershell
> INFO REPLICATION
# Replication
role: slave
master_host:127.0.0.1
master_port:6001
...
master_replid: e3b07d3eba52283842a2403aa3823489a
master_repl_offset: 709
...
```

- 연결된 마스터 정보와 offset 확인 가능

## 부분 재동기화

👴🏻: 복제 연결이 끊길 때마다 새로 복제할 건가? 성능 나빠질텐데…

👼🏻(마스터): 저 백로그 버퍼 있어요

### 백로그 버퍼

마스터가 커넥션 유실을 대비해 메모리에 복제본에 전달한 커맨드를 저장해둔 공간

- 복제 id와 오프셋을 통해 복제본이 어느 시점에 데이터까지 가지고 있는지 파악할 수 있다.
    - 복제본이 `PSYNC` 커맨드를 호출해 **자신의 복제 id와 오프셋을 전달**하면 **부분 재동기화**가 가능하다.
- **전체 재동기화를 해야 하는 경우**
    - 백로그 버퍼에 데이터가 남아있지 않음
        - 복제 백로그 크기: `repl-backlog-size` 파라미터로 설정 (기본값 1MB)
        - 백로그 데이터 ttl: `repl-backlog-ttl`
    - 복제본이 보낸 복제 id가 마스터와 일치하지 않음

### Secondary 복제 id

- 한 개 복제본 그룹 내 모든 레디스 노드는 동일한 복제 id(master_replid)를 갖는다.
- 마스터 노드와의 복제가 끊어지면 복제본은 새로운 복제 id를 갖고 이를 공유한다.
    - 원래 복제 id는 master_replid2에 저장된다.
- 마스터로 승격된 노드와 복제본이 새롭게 복제 연결이 될 때 **부분 재동기화를 시도**한다.
    - master_replid2가 같으면 같은 마스터 출신이니까 😎

**→ 마스터로 승격되는 복제본 때문에 레디스는 2개의 복제 id를 갖는다.**

**→ 페일오버 이후 승격된 마스터에 연결된 복제본은 부분 재동기화를 통해 효율적인 복제가 가능하다.**

# 유효하지 않은 복제본 데이터

복제본의 데이터와 마스터의 데이터가 정확하게 일치하지 않는 경우

## 복제본은 어떻게 동작할까?

`replica-serve-stale-data` 파라미터로 제어

- **(default) yes**: 클라이언트로부터 들어오는 모든 읽기 요청에 데이터를 반환
- **no**: 일부 기본 커맨드를 제외한 모든 커맨드에 대해 오류 반환
    - SYNC with master in progress

# 데이터 복제 without 백업

## 장애 상황

1. 마스터 노드가 장애로 종료
2. 레디스 프로세스를 자동 재시작하는 시스템에 의해 노드 재부팅 (메모리 초기화)
3. 복제본 노드에는 데이터가 존재하지만, 마스터 노드로의 복제 연결 시도
4. **마스터에서 복제본으로 빈 데이터셋 전달 😱**

## 해결 방법

1. 복제를 사용하는 경우 백업 기능도 사용하자.
2. 재부팅 후 레디스가 자동으로 재시작되지 않도록 설정하자.
