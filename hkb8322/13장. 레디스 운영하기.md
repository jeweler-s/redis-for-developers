# 레디스 모니터링 구축하기

- `익스포트` : 시스템의 상태를 실시간으로 스크랩하여 메트릭을 수집하는 프로그램
- `레디스 익스포트` : 지정한 레디스 인스턴스의 실시간 정보 수집
- `노드 익스포터` : 레디스가 실행되는 서버의 하드웨어와 OS 관련 메트릭 수집

## 1) 프로메테우스와 그라파나를 이용한 레디스 모니터링

### 주요 개념

- `프로메테우스` : 메트릭 기반의 오픈 소스 모니터링 시스템
- `그라파나` : 오픈 소스 메트릭 데이터 시각화 소스
- `얼럿 매니저` : 모니터링 대상이 특정 임게치에 도달한 경우 사용자에 통지하는 프로그램

### 과정

1. 노드 익스포터 설치
2. 레디스 익스포터 설치
3. 얼럿 매니저 설치
4. 프로메테우스 설치
5. 그라파나 설치
6. 대시보드 생성

## 2) 레디스 플러그인을 이용한 그라파나 대시보드

- 그라파나 내 레디스 플러그인 설치 시 `RedisGrafana` 에서 제공하는 대시보드 이용하여 레디스 상태 확인 가능
- 프로메테우스 설치 불필요

# 레디스 버전 업그레이드

## 레디스 서버 버전 확인

```bash
$ bin/redis-server -version
```

## 센티널 구성의 레디스 버전 업그레이드

### 서버 구성

- 인스턴스 3대
    - A : Master, Sentinel
    - B : Slave, Sentinel
    - C : Slave, Sentinel

### 과정

**1) 신규 버전의 레디스 바이너리 파일 다운로드**

```bash
$ wget http://download.redis.io/releases/redis-7.0.7.tar.gz
$ tar -zxvf redis-7.0.7.tar.gz
$ rm redis-7.0.7.tar.gz
$ cd redis-7.0.7
$ make
$ make install
$ mv /home/centos/redis /home/centos/redis-old
$ mv /home/centos/redis-7.0.7 /home/centos/redis
```

- 신규 버전 레디스 다운로드 후 압축 해제
- 기존 버전의 레디스 폴더는 `redis-old`로, 신규 다운로드한 버전을 `redis`로 변경
- 센티널, 복제본, 마스터 인스턴스 모두 수행

**2) [센티널] 3대의 인스턴스 모두 중단**

```bash
$ redis-cli -p 26379 shutdown
```

### 3) [센티널] 신규 버전 폴더에 기존의 `sentinel.conf` 복사

```bash
$ cp /home/centos/redis-old/sentinel.conf /home/centos/redis/sentinel.conf
```

### 4) [센티널] 신규 바이너리 파일을 이용해 3대의 인스턴스 시작

```bash
$ /home/centos/redis/src/redis-sentinel /home/centos/redis/sentinel.conf
```

- 센티널 인스턴스 업그레이드

### 5) [복제본] 인스턴스 중단

```bash
$ redis-cli config rewrite # 인스턴스 정보 설정 파일에 반영
$ redis-cli shutdown
```

- 복제본 인스턴스 중단 전 실행 중인 인스턴스 정보가 설정 파일에 반영될 수 있도록 `config rewrite` 수행 권장

### 6) [복제본] 신규 버전 폴더에 기존 `redis.conf` 복사

```bash
$ cp /home/centos/redis-old/sentinel.conf /home/centos/redis/sentinel.conf
```

### 7) [복제본] 신규 바이너리 파일을 이용해 복제본 인스턴스 시작

```bash
$ /home/centos/redis/src/redis-server /home/centos/redis/redis.conf
```

- 이후 로그 파일 확인하여 인스턴스가 업그레이드 되었는지 확인 필요

### 8) [센티널] 수동 페일오버 수행

```bash
127.0.0.1:26379 > sentinel failover mymaster # 이때, 마스터 <-> 복제본 간 롤 체인지 발생
```

### 9) [마스터] 인스턴스 업그레이드

- 5~7 과정 반복
    1. 기존 마스터 인스턴스 중단
    2. 신규 버전 폴더에 기존의 `redis.conf` 복사
    3. 신규 바이너리 파일을 이용해 기존 마스터 인스턴스 시작

### 10) [센티널] 수동 페일오버 수행

- `slave` 로 변경된 기존 마스터를 다시 승격시키기 위해 다시 센티널에서 수동 페일오버 수행

## 클러스터 구성의 레디스 버전 업그레이드

### 서버 구성

- 마스터 : A, B, C
- 복제본 : D, E, F

### 과정

1. 복제본(D, E, F) 노드 각각 업그레이드
2. D 노드에서 페일오버
    1. 복제본 : `CLUSTER FAILOVER` 커맨드 실행
    2. 마스터 : FAIL 상태로 변경
    3. 복제본 : 마스터로 승격
3. A 노드 업그레이드
4. E 노드에서 페일오버
5. B 노드 업그레이드
6. F 노드에서 페일오버
7. C 노드 업그레이드

# 레디스 운영 가이드

## 1) 장애 또는 성능 저하를 유발할 수 있는 레디스 설정

### `maxmemory-policy`

- 레디스가 메모리 한계에 도달했을 때 어떤 키를 제거할지 결정하는 설정값
- 기본 값 : `noeviction`
    - 메모리에 데이터가 가득 차도 임의로 삭제하지 않고 저장 불가 오류 반환
    - 데이터 유실은 방지할 수 있으나 애플리케이션으로 이어질 가능성 존재
- ✅ `allkeys-lru` : 데이터가 임의로 삭제되더라도 계속해서 새로운 입력을 받아들일 수 있음

### `stop-writes-on-bgsave-error`

- RDB 스냅샷이 정상적으로 저장되지 않은 경우 레디스로의 모든 쓰기 작업 중지,
    
    최신 백업이 실패한 것을 인지하여 서버에 문제가 있음을 알려줘 더 큰 장애 방지 가능
    
- 기본 값 : `YES`
- 레디스 서버에 이미 다른 모니터링 기능이 활성화되어 있어 디스크 문제도 감지 가능하고,
    
    레디스 쓰기 작업은 중단하지 않고 계속되길 원한다면 비활성화 필요
    

### 자동 백업 옵션

- 백업이 포그라운드로 실행될 경우 메인 스레드는 실행 중 다른 작업을 하지 못하여 성능 저하
- 백그라운드로 실행될 경우 COW(Copy On Write) 방식으로 작동하여 `maxmemory` 설정의 두 배까지 메모리 증가 가능
    
    ⇒ 최악의 경우 OOM 발생
    

```
💡 COW(Copy On Write)란?
리눅스에서 자식 프로세스 생성 시 부모-자식 간은 같은 메모리를 공유하는데,
이때 부모 프로세스가 write 대상 페이지를 복사 후 수정하는 것을 말함
이로 인하여 더 많은 메모리가 필요하게 됨

레디스에서 COW가 발생 조건은 아래와 같다.
* save 파라미터
* BGSAVE 명령어
* 복제
* auto-aof-rewrite-percentage 파라미터
* BGREWRITEAOF 명령어
```

`**save**`

- 일정한 기간 동안 변경된 키 수의 개수가 조건에 맞을 때 자동으로 RDB 파일 생성
- ✅ 운영자가 원하는 시간에 백업이 수행되도록 기본 설정값을 사용하지 않는 것이 좋음
    
    ```bash
    > CONFIG SET save ""
    ```
    

`**appendonly**`

- 옵션을 `yes` 로 설정하여 AOF 형식의 백업을 수행하는 경우 주의 필요
- AOF 파일 크기가 기존 AOF 파일보다 100% 증가 시 자동 재작성 발생
- 이러한 동작을 의도하지 않은 경우 아래와 같이 설정
    - `auto-aof-rewrite-percentage` : 0

## 2) 레디스 운영 및 성능 최적화

### 오래 걸리는 커맨드 사용 지양

- 레디스는 싱글 스레드로 동작하며, 클라이언트의 모든 요청은 이벤트 루프를 이용해 순차적으로 실행
- 하나의 자료 구조 안에 여러 개의 아이템을 가진 경우, 해당 자료 구조에 대한 커맨드도 아이템 개수에 비례해 실행 시간 증가

**키스페이스 커맨드**

- `KEYS` : 레디스에 저장된 모든 키에 하나씩 접근, O(N)
- `FLUSHALL` : SYNC 방식으로 동작, O(N)
    - `ASYNC` 옵션 사용 시 백그라운드에서 수행
- `FLUSHDB` : SYNC 방식으로 동작, O(N)
    - `ASYNC` 옵션 사용 시 백그라운드에서 수행
    - 명령어 수행 중 새로 생성된 키는 삭제되지 않음

```
💡 LAZY FREEING
레디스는 비동기적으로 메모리를 해제하는 UNLINK 삭제 방식 제공
키 삭제 시나리오에서 설정값을 변경해 비동기로 삭제 가능하도록 구성 가능

* lazyfree-lazy-eviction : 메모리 제한을 위한 삭제 시 비동기화 여부
* lazyfree-lazy-expire : 만료된 키 삭제 시 비동기화 여부
* lazyfree-lazy-server-del : 서버 동기화나 다른 명령의 사이드이펙트로 인한 키 삭제 시 비동기화 여부
* replica-lazy-flush : 복제 동기화 중 DB 내용 삭제 시 비동기화 여부
* lazyfree-lazy-user-del : 사용자 코드에서의 DEL 호출 시 비동기화 여부

하지만, 위 설정값을 `yes`로 지정해도 동기적으로 삭제될 수 있음
메모리 해제 시 필요 노력 평가를 통해 노력이 64보다 크고 객체 참조 카운트가 1인 경우에만 비동기적으로 메모리 해제
* `free_effort > LAZYFREE_THRESHOLD(=64) && obj->refcount == 1`
```

**자료 구조 공통 커맨드**

- `DEL` : 자료구조에 따라 O(1) 또는 O(N), 아이템이 많을 경우 `UNLINK` 사용 필요
- `SORT` : O(N + Mlog(M))
- `SO**RT_RO` :** `SORT`와 동일하지만 `STORE` 옵션 사용 불가, 버전 7에서 추가

⇒ 정렬이 필요한 경우 자료 구조 내 아이템 수를 적정하게 관리 필요

`**set` 관련 커맨드**

- `SDIFF` / `SDIFFSTORE` : 차집합 수행, O(N)
- `SUNION` / `SUNIONSTORE` : 합집합 수행, O(N)
- `SINTER` / `SINTERSCORE` / `SINTERCARD` : 교집합 수행, O(N * M)

`**list` 관련 커맨드**

- `LINDEX` : 입력받은 인덱스 위치에 있는 아이템 반환, O(N)
- `LINSERT` : 피봇 전후로 신규 아이템 입력, O(N)
- `LSET` : 특정 인덱스의 아이템을 신규 입력한 문자열로 변경, O(N)
- `LPOS` : 아이템의 인덱스 반환, O(N), 버전 6.0.6에서 추가됨

`**hash` 관련 커맨드**

- `HGETALL` : 모든 아이템의 키와 값 리턴, O(N)
- `HKEYS` : 모든 키 리턴, O(N)
- `HVALS` : 모든 값 리턴, O(N)

`**sorted set` 관련 커맨드**

데이터 입력 시 자동 정렬되므로 기본적으로 O(log(N)) 

- `ZDIFF` / `ZDIFFSTORE` : 차집합, O(L + (N-K)log(N))
- `ZUNION` / `ZUNIONSTORE` : 합집합, O(N) + O(M*log(M))
- `ZINTER` / `ZINTERSTORE` : 교집합, O(N*K) + O(M*log(M))
- `ZINTERCARD` : 교집합 카디널리티 반환, O(N*K)

### 레디스에서의 트랜잭션

- 싱글 스레드로 동작하기 때문에 트랜잭션 사용 시 주의 필요

**MULTI / EXEC** 

- `MULTI` : 트랜잭션 시작
- `EXEC` : 입력했던 커맨드 원자적으로 실행 ,성공 시 결과 반환, 오류 발생 시 모든 커맨드 롤백 및 트랜잭션 종료

**루아 스크립트**

- 빠르고 가벼운 임베디드 가능 스크립트 언어
- 간단한 문법과 빠른 실행 속도 보유
- 레디스 내 원자적으로 실행됨
    - 여러 명령 한 번에 실행 가능
    - 다른 클라이언트 요청을 수용하지 않아 데이터 일관성 유지 가능
- 일부 명령어 실패 시에도 롤백되지 않고 다음 명령어 실행
- 주요 명령어
    - `SCRIPT LOAD` : 루아 스크립트를 레디스에 로드, 스크립트 해시 값 반환
    - `EVALSHA` : 스크립트 해시 값을 통하여 스크립트 실행 가능

**주의사항**

- 트랜잭션과 루아 스크립트 사용 도중 다른 클라이언트의 커맨드는 모두 대기
- 블로킹 커맨드 사용 불가

### ⭐ `has-get` / `has-del` 패턴 지양

- 애플리케이셔 ㄴ내 데이터 존재 여부 확인 후 데이터 조회 및 삭제하는 패턴은 RTT 증가의 원인
- 네트워크 지연 야기 및 레디스 서버와 불필요한 통신 유발
- 레디스에서는 키가 존재하지 않는 경우 명령어별로 아래와 같이 동작
    - `GET` : nil 반환
    - `DEL` : 오류 X

### 클라이언트 출력 버퍼 사이즈

```bash
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8bm 60
```

- 클라이언트 출력 버퍼는 클라이언트가 서버로부터 응답을 받을 때 일시적으로 저장하는 역할 수행
    - 서버-클라이언트 간 통신 속도 차이나 부하 등으로 발생 가능한 버퍼 오버플로우 방지, 안정적인 통신 보장
- 동시에 많은 클라이언트 요청 처리 시 버퍼 크기를 늘리는 것이 좋음
- 복제를 사용하는 경우 버퍼 크기를 늘리는 것이 필수적
    - 큰 데이터 복제 시 기본 값으로 설정된 출력 버퍼 크기가 부족할 수 있음
- ⭐ `**maxmemory`를 늘리거나 `maxclients` 설정을 확장할 때 복제본에 대한 출력 버퍼 사이즈를 동시에 조절하는 것이 중요**

### 키 만료 모니터링

```bash
> CONFIG SET notify-keyspace-events Ex
```

- 키스페이스 알림 기능은 내부 키에 대한 변경사항을 모니터링하며 pub/sub 채널을 이용해 변경 사항에 대한 메시지를 구독하는 기능
- `notify-keyspace-events` 설정을 통해 활성화
- 동시에 수많은 이벤트 발행 시 버퍼 크기를 초과한다면 새로운 이벤트 메시지가 버퍼에 저장되지 못하고 유실될 가능성 존재
    - ❗ pub/sub은 `fire and forget` 방식으로 작동하기 때문에 한 번 발행된 이벤트는 재확인 불가
- 이때 아래 솔루션 고려 가능
    - pub/sub 버퍼 크기 확장
    - 여러 개의 인스턴스를 사용해 이벤트 분산

**알림 종류**

- `K` : 키스페이스 이벤트 (keyspace@<db> 접두사 포함 발행)
- `E` : 키 이벤트 (keyevent@<db> 접두사 포함 발행)
- `g` : 일반 명령 이벤트
- `$` : 문자열 명령어 관련 이벤트
- `l` : 리스트 명령어 관련 이벤트
- `s` : 집합 명령어 관련 이벤트
- `h` : 해시 관련 명령어 이벤트
- `z` : 정렬 집합 관련 명령어 이벤트
- `t` : 스트림 관련 명령어 이벤트
- `x` : 만료된 키 이벤트
- `e` : 삭제된 키 이벤트
- `m` : 누락된 키 이벤트, 존재하지 않는 키 접근 시 발생
- `n` : 새로운 키 이벤트
- `A` : `g$lshztxed` 별칭
- 

### 특정 프리픽스를 가진 키 삭제

```bash
418pg 루아 스크립트 참조
```

- 다른 클라이언트에게 영향을 미치지 않는 적절한 배치 크기로 `count` 매개변수 조절하여 차단 시간 최소화
- ⭐ 레디스를 사용할 때 주로 고려해야 할 부분은 네트워크 통신 시간,
    
    네트워크 통신 최적화 시 전반적인 성능 향상 가능
    

## 3) 레디스 모니터링

### 슬로우 로그

```bash
$ redis-cli SLOWLOG GET
```

- 실행 속도가 느린 커맨드 조회
- 주기적으로 모니털이하여 느린 커맨드를 추적하고 디버깅하여 성능 향상
- 아래 내용 조회 가능
    - `실행 시각(timestamp)` : 명령이 실행된 시각 정보
    - `소요 시간(ms)` : 명령이 실행되는 데 소요된 시간
    - `명령` : 명령이 실행되는 데 소요된 시간
    - `인자` : 느린 명령에 대한 인자 정보

유관 설정

- `slowlog-log-slower-than` : 슬로우 로그에 남는 기준 (기본 값 10,000ms)
- `slowlog-max-len` : 슬로우 로그에 유지되는 레코드 개수 (기본 값 128개)

### 그래프 지표

**CPU**

- 시간 복잡도가 높은 커맨드 빈번히 사용 시 CPU 부하 가능
- 집합 자료 구조의 카디널리티가 높을수록 성능 저하 원인이 될 가능성 존재
- 읽기 작업이 부하를 일으키는 경우 읽기 작업을 복제본을 참조하도록 변경 필요
- 가급적 백업을 복제본에서 수행, 복제 환경에서는 전체 재동기화가 빈번하게 발생하지 않도록 해야 함

⭐ **메모리**

- **핵심 지표**
    - `used_memory` : 현재 할당한 메모리
    - `BytesUsedForCache` : 현재 메모리 사용량
    - `DatabaseMemoryUsagePercentage` : `maxmemory` 백분율 계산
    - `used_memory_rss` : 운영체제가 레디스 프로세스에 할당한 실제 물리 메모리양
- 데이터셋의 크기와 TTL을 고려해 메모리 사용량 관리
- 메모리 사용량이 급증하는 경우를 대비해 감지 가능한 알람 설정 필요
- 논리 메모리에 비해 물리 메모리가 너무 커질 경우 단편화 문제 발생하여 메모리 효율성 저하 가능
- 메모리 단편화를 관리하기 위해 `active defragmentation`  기능 활성화 가능
    
    ```bash
    CONFIG SET activedefrag yes
    ```
    
    - 레디스 4.0 이상에서 사용 가능
    - 단, 단편화 문제가 없다면 활성화 불필요

**네트워크**

- 가상 머신, 도커, 쿠버네티스 등의 환경에서 레디스 사용 시 레디스가 실행되는 노드의 네트워크 처리 대역폭 한계에 도달하면 성능 저하 가능
- 네트워크로 인해 낮은 처리량을 내는 경우 존재
- **해결 방안**
    - 읽기 작업으로 인한 네트워크 사용량 증가 시
        - 복제본을 주로 활용하고 있는지 확인 필요
        - 이미 사용하는 경우 추가 복제본 구성
    - 쓰기 작업으로 인한 네트워크 증가 시
        - 레디스 서버 사양 업그레이드
        - 더 많은 네트워크 대역폭을 사용할 수 있는 환경으로 이동
        - 클러스터 모드로 변경해 쓰기 작업이 여러 노드에 분산되도록 함

**커넥션**

- 갑작스럽게 활성 연결 수가 증가하는 경우 아래 내용 확인 필요
    - 애플리케이션에서 문제가 발생했는지
    - 연결이 올바르게 종료되지 않아 레디스에 유지되는지
- `tcp-keepalive` 설정 사용 시 유휴 연결로 인한 문제 예방 가능
    - 기본 설정 유지 시 300초마다 연결 유효성 검증 후 문제가 있는 경우 연결 종료
- 또한, 애플리케이션에서 연결을 재사용하기 위한 커넥션 풀링 활용 필요
- TLS를 사용해 통신하는 경우 새로운 연결의 양 제어 필요
    - TLS 핸드셰이크 과정에서 기존 연결보다 더 많은 시간과 CPU 자원 소모

**복제**

- **복제 지연 발생 원인**
    - 마스터 노드로의 많은 쓰기 작업
    - 네트워크 대역폭의 고갈
    - 복제 출력 버퍼 크기의 문제
- 복제 지연 발생 시 복제본이 전체 동기화를 수행해야 할 수도 있음,
    
    이때 마스터 노드에서 스냅샷을 생성하기 때문에 레디스 성능 저하 초래 가능
