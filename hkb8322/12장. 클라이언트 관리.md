# 클라이언트 핸들링

- 레디스는 클라이언트 연결 수락 시 TCP 포트와 유닉스 소켓 사용 가능
- 일반적으로는 사용자 연결을 받기 위해 TCP 포트 사용

### 유닉스 소켓 설정

```bash
# redis.conf
unixsocket /tmp/redis.sock
usnixocketperm 777
```

- 위와 같이 설정하여 원하는 경로에 소켓 파일을 생성하고 해당 파일의 권한 부여 가능
- 위와 같이 설정 후 레디스 시작 시 원하는 경로에 파일 생성 후 소켓 통신 활성화

### 소켓 파일을 활용한 레디스 서버 연결

```bash
redis-cli -s /tmp/redis.sock
```

- 이후에는 클라이언트가 해당 유닉스 소켓 파일의 경로를 사용해 레디스 서버 연결 가능

### 레디스의 멀티플렉싱

- **하나의 통신 채널을 통해 여러 데이터 스트림 전송**
- **하나의 스레드에서 여러 소켓을 감시하고 소켓 이벤트가 발생하는지 지속적으로 확인**
- 따라서 효율적인 다중 클라이언트를 지원하게 하고,
    
    많은 클라이언트 요청을 동시에 처리하는데 블로킹 문제를 피할 수 있었음
    
- 논블로킹 I/O를 통해 I/O 작업이 완료될 때까지 기다리지 않고 다른 작업 처리,
    
    클라이언트 요청을 비동기로 처리하고 다수 클라이언트 요청 동시 처리
    

[[네트워크] 멀티플렉싱(Multiplexing)](https://12bme.tistory.com/741)

### `TCP_NODELAY` 옵션

- 사용 시 소켓은 작은 데이터라도 버퍼링하지 않고 지연 없이 가능한 한 빨리 패킷 전송 시도
- 주로 작은 데이터 조각을 실시간으로 전송해야 하는 경우 사용
- 클라이언트 연결 지연 최소화
- 버전 7 기준 해당 옵션 해제 불가, 하지만 복제 연결 시 아래와 같이 해제 가능
    
    ```bash
    # redis.conf
    repl-disable-tcp-nodelay yes
    ```
    

### 클라이언트 소켓 통신 과정

1. 새로운 데이터 도착 시 읽기 가능한 파일 이벤트 생성
2. 레디스는 이를 이용해 클라이언트에서 전송한 쿼리 수집 및 처리
3. 클라이언트 초기화 시 레디스는 `maxclients` 설정값과 비교해 현재 클라이언트 수가 `maxclients` 값에 도달했는지 확인
4. 위 값을 초과한 경우 연결 거부

### 운영체제와 `maxclients`

- 버전 2.6 이후 기본적으로 `maxclients` 수가 `10000`으로 설정
    
    (별도로 변경하지 않을 경우 유지)
    
- 레디스 시작 시 운영체제 설정 값을 확인해 클라이언트 수 제한 가능
- `maxclients` + 32(레디스가 예약한 파일 디스크립터 수) > 운영체제 파일 디스크립터 수
    - 이 경우 운영체제 파일 디스크립터 수에 맞게 레디스 인스턴스가 시작됨
    - 2장 48pg 참고

## 클라이언트 버퍼 제한

- 클라이언트에 반환할 데이터를 임시로 저장하기 위해 각 클라이언트마다 출력 버퍼 생성
- 출력 버퍼는 레디스가 반환할 데이터 양에 따라 가변
- 클라이언트가 데이터를 처리하지 못하고 계속 서버에 요청을 보내면 버퍼가 증가하여 메모리 사용량 증가로 이어짐
- **출력 버퍼 크기에 대한 제한을 두어 버퍼 크기가 일정 수준 이상으로 증가할 경우 연결 종료**
    - 일반 클라이언트는 출력 버퍼 크기 제한이 없음
    - PUB/SUB의 경우 하드 제한은 32MB, 소프트 제한은 60초당 8MB
        
        (클라이언트가 빠르게 처리되는 메시지들을 처리하기 위해 더 많은 메모리 공간이 필요)
        
    - 복제본의 경우 하드 제한은 256MB, 소프트 제한은 60초당 64MB
        
        (복제본이 마스터로부터 대량 데이터를 받는 경우에 대한 고려)
        

### 하드 제한

- 고정된 제한 값
- 여기에 도달하면 레디스는 클라이언트 연결을 빨리 닫음

### 소프트 제한

- 시간에 따라 제한 값이 달라짐

### 버퍼 제한 변경

```bash
CONFIG SET client-output-buffer-limit <class> <hard-limit> <soft-limit> <soft-limit-duration>
```

- `class` : normal, slave(replica), pubsub
- `hard-limit` : 하드 제한 (바이트 단위)
- `soft-limit` : 소프트 제한 (바이트 단위)
- `soft-limit-duration` : 소프트 제한이 적용되는 시간 간격 (초 단위)

### 클라이언트 쿼리 버퍼

- 클라이언트에서 받은 커맨드를 레디스에서 잠시 보관하는 내부 버퍼
- 기본적으로 1GB로 설정
- `client-query-buffer-limit` 설정을 변경하여 이용 가능

## 클라이언트 Eviction

- 클라이언트 연결 수 증가 시 메모리 사용량도 증가하여 OOM 또는 데이터 만료 유발 가능
- 임계치 도달 시 가장 많은 메모리를 사용하는 연결부터 해제, 이를 Client Eviction이라 함
- 복제 연결에 사용되는 복제본과 마스터 커넥션은 클라이언트 이빅션 기능에 영향 ❌

### 버전 7 이전

- `maxmemory-policy` 설정 값을 통해 메모리 한도 관리 가능

### 버전 7 이후

```bash
maxmemory-clients 1G # 특정 크기 직접 지정
maxmemory-clients 5% # 퍼센트 단위로 설정
```

- `maxmemory-clients` 설정 값을 통해 모든 클라이언트 연결이 사용하는 누적 메모리 양 제한 가능
    - `redis.conf` 또는 `CONFIG SET` 통하여 설정
- 레디스에 연결된 모든 클라이언트의 최대 총 메모리 사용량 정의
    - 쿼리 버퍼, 출력 버퍼, 중간 버퍼 등 클라이언트에서 사용하는 메모리 포함
- 기본 설정값은 `0` , 기본적으로 해당 기능 비활성화
- 대규모 트래픽 환경에서는 `5%`, `10%` 와 같은 값 설정 권장 ✅

### 특정 클라이언트 이빅션 제외 처리

```bash
> CLIENT NO-EVICT on
OK
```

- 주기적으로 모니터링하고 알림을 보내는 경우 위와 같이 설정 가능
- 연결이 강제로 끊기지 않도록 함

## Timeout과 TCP KeepAlive

- 클라이언트 연결 이후 장기간 동안 커맨드 미수행 시에도 연결은 계속 유지됨

### 타임아웃 설정

```bash
CONFIG SET timeout 600
```

- 기본 값  : `0`
- 타임아웃 설정을 사용해 특정 시점에서 활동이 없는 클라이언트 정리 가능
- 레디스 서버가 동작 중일 때 변경 가능
- pub/sub 클라이언트에는 영향을 주지 않음

### Keep-Alive

- `tcp-keepalive` 설정을 통해 연결된 클라이언트에게 주기적으로 TCP ACK를 보내고, 응답이 없는 경우 연결을 끊을 수 있음
- 3.2.0 버전부터 `300초`로 설정되어 있어, 서버는 연결된 클라이언트에게 5분마다 한 번씩 TCP ACK 전송
- **타임아웃과 달리 즉시 연결을 끊는 게 아니라 실제로 클라이언트가 정상적으로 응답할 수 있는 상태인지를 우선적으로 확인한 뒤, 응답하지 않는 경우에만 연결 해제**
- 정기적으로 TCP ACK를 보내면 레디스-클라이언트 사이 네트워크 장비에서 연결이 유지되고 잇음을 확인할 수 있는데, 이를 통해 예기치 않은 연결 종료 방지 및 문제 조기 감지 가능

# 파이프라이닝

```bash
$ (printf "PING\r\nPING\r\nPING\r\n", sleep 1) | nc localhost 6379
```

- 클라이언트가 연속적으로 여러 개의 커맨드를 레디스 서버에 보낼 수 있도록 하는 기능
    
    (응답 속도 줄이고, 처리량 늘림)
    
- 레디스에서 클라이언트에 응답하기 위해 소켓 I/O 수행 시..
    
    **커널 영역의 시스템 콜 호출 시 지연 시간 > 레디스 데이터 조회 및 반환**
    
- 예제 기준 파이프라인 사용 시 142배의 성능 향상

```
💡
nc(netcat) 명령어란?
TCP/UDP를 통해 네트워크 연결에서 데이터를 읽고 쓸 수 있는 유틸리티
```

## 주의 사항

- 한 번에 너무 많은 쿼리 수행 시 네트워크 대역폭 한계로 인해 속도 저하
    
    또는 클라이언트 쿼리 버퍼 제한에 걸려 오류 발생 가능
    
    ⇒ 여러 개의 명령을 일정한 개수로 나누어 배치 형태로 서버에 실행하는 것이 좋음
    
- 배치 사이즈는 테스트를 통하여 결정하는 것이 좋음
- **명령 처리 시 하나의 파이프라인에 속하더라도 원자성을 보장하지 않음**
    
    내부 각 커맨드만이 원자적으로 수행됨, 트랜잭션 개념이 아님
    
- 커맨드 중 일부에 오류 발생 시 해당 커맨드만 수행되지 않음 (나머지는 정상 수행)

# 클라이언트 사이드 캐싱

- 네트워크 I/O 왕복 시간을 줄이기 위해 클라이언트에서 데이터를 로컬에 캐싱,
    
    필요할 때 해당 데이터를 반환하는 것
    
- 데이터가 자주 변경되지 않는 상황에서는 클라이언트 사이드 캐싱을 사용하는 것이 합리적
- 하지만 업데이트된 데이터의 캐시 처리에 대한 고민 필요
    
    ⇒ 이를 위한 처리 방법인 트래킹이 버전 6에서 도입됨
    
- 서비스 특성에 맞게 캐싱 모드를 신중히 고려
- 자주 요청되지만 드물게 변경되는 키를 캐싱하는 것이 효과적

## 기본 모드

- 레디스 서버가 클라이언트가 액세스한 키를 기억하여 동일 키 수정 시 무효 메시지 전송
- 레디스 서버에서 이를 기억해야 하기 때문에 메모리 비용이 듦

## 브로드캐스팅 모드

- 특정 프리픽스에 대해 접근한 클라이언트만 기억
- 기본 모드보다 레디스 서버에서 사용하는 메모리가 적음
- 클라이언트가 사용하지 않는 키라도 프리픽스와 일치하는 키가 변경될 때마다 변경 메시지 수신
    
    ⇒ 이로 인한 CPU 자원 소비 가능성 존재
