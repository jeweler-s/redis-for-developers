# 6장. 레디스를 메시지 브로커로 사용하기

# 메시징 큐와 이벤트 스트림

## 차이점

1. **방향성**
    - **메시징 큐** :  생산자는 소비자의 큐로 데이터 직접 푸시, 구독 서비스별로 큐 분리 필요
    - **스트림** : 생산자는 스트림의 특정 저장소에 하나의 메시지를 보내고, 소비자들이 스트림에서 같은 메시지를 읽어감
2. **데이터의 영속성**
    - **메시징 큐** : 소비자가 데이터를 읽어갈 때 큐에서 데이터 삭제
    - **스트림** : 구독자가 읽어간 데이터는 바로 삭제되지 않고 저장소 설정에  따라 특정 기간 유지
3. **용도**
    - **메시징 큐** : 일대일(1:1) 상황에 유리
    - **스트림** : 다대다(N:M) 상황에 유리

## 레디스를 메시지 브로커로 사용하기

- 모든 데이터는 한 번 채널에 전파된 뒤 삭제됨
- 메시지가 잘 전달됐는지 보장하지 않음
- 알림과 같은 fire-and-forget 패턴에 유리

# 레디스의 pub/sub

레디스 노드에 접근하는 모든 클라이언트는 발행자와 구독자가 될 수 있음

## 메시지 발행

```java
PUBLISH {channel} {message}
```

## 메시지 구독

```java
SUBSCRIBE {channel-1} {channel-2} ...
```

- 클라이언트가 구독자인 경우 새로운 채널 구독만 가능
    - pub/sub과 관련되지 않은 다른 커맨드 수행 불가
- 수행 가능 커맨드
    - SUBSCRIBE
    - SSUBSRIBE
    - SUNSUBSCRIBE
    - PSUBSCRIBE : 일치하는 패턴에 해당하는 채널 일괄 구독 (glob-style 패턴 지원)
    - UNSUBSCRIBE
    - PUNSUBSCRIBE
    - PING
    - RESET
    - QUIT

<aside>
💡 **Glob Pattern이란?**
리눅스 운영체제에서 한 번에 여러 개의 파일을 찾을 때 사용해온 패턴 매칭 기법
****현재 리눅스 뿐만 아니라 Shell, Java, Python, NodeJS, Go, Ruby, PHP 등 대부분의 프로그래밍 언어에서 지원하고 있음. 특히, 운영 체제와 프로그래밍 언어를 가리지 않고 프레임워크나 라이브러리를 설정할 때 광범위하게 사용되고 있음.

</aside>

### 메시지 타입

- message
- pmessage

## 클러스터 구조에서의 pub/sub

- 레디스 클러스터에서 pub/sub 사용하는 경우 메시지 발행 시 해당 메시지는 클러스터에 속한 모든 노드에 자동 전달
- 하지만 이는 클러스터의 핵심 목표와는 부합하지 않고 불필요한 리소스 사용과 네트워크 부하 발생 가능
    - 클러스터는 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입

## Sharded pub/sub

- 레디스 7.0에서 도입
- 각 채널은 슬롯에 매핑, 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지 전파
- `SPUBLISH` 커맨드 사용하여 발행
- 모든 노드로 메시지가 전파되지 않아 불필요한 복제 줄여 자원 절약

<aside>
💡 **슬롯이란?**
클러스터 키를 `해시함수`로 적용하여 나온 값을 지정한 각 서버에 매핑하여 저정할 수 있게 해주기 위해 설정, 클러스터에 키를 `분산되서 저장`하기 위해 사용

</aside>

[Redis Cluster 및 Slot 를 구성해보자!](https://velog.io/@limsubin/Redis-Cluster를-구성해보자#span-stylecolorlightcoral-slot-이란-span)

# 레디스의 List를 메시징 큐로 사용하기

## 트위터의 타임라인 구현

- `RPUSHX` 명령어를 통해 타임라인 캐시가 존재하는 유저의 타임라인에만 팔로우중인 유저의 게시글이 조회되도록 처리

## 블로킹 기능

- 이벤트가 존재하는지 주기적으로 체크하는 폴링으로 인하여 성능 저하 및 이벤트 즉시 처리 불가
- `BRPOP`, `BLPOP` : 리스트에 데이터가 존재하는 경우 즉시 반환
    - 데이터가 없을 경우 데이터가 들어올 때까지 기다린 후 값 반환 또는 타임아웃 이후 NIL 반환

## 원형 큐 구현

- 특정 아이템을 반복 접근  또는 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 경우 원형 큐가 필요할 수 있음
- `RPOPLPUSH` : `RPOP` 수행 후 `LPUSH` 진행

# Stream

## 스트림이란?

- 연속적인 데이터의 흐름, 일정한 데이터 조각의 연속

## 데이터 저장

### 카프카

- 토픽(분리된 스트림)에 데이터가 저장됨, 같은 데이터를 관리하는 하나의 그룹
- 각 메시지는 0부터 시작해 증가하는 시퀀스 넘버로 식별 가능
- 시퀀스 넘버는 토픽 내 파티션 내에서만 유니크하게 증가

### 레디스

- `stream` 자료 구조가 하나의 스트림을 의미
- 시간과 관련된 유니크 ID(`<millisecondsTime>-<sequenceNumber>`)를 가짐, 중복되지 않음
    - millisecondsTime : 아이템이 저장될 시점의 레디스 노드 로컬 시간
    - sequenceNumber : 동일한 밀리세컨드 시간에 여러 아이템이 저장 가능하도록 함

## 스트림 생성과 데이터 입력

### 카프카

- 생성자는 토픽에 데이터 푸시, 소비자는 토픽에서 데이터를 읽어감
- 데이터 저장을 위해 토픽 생성 후 프로듀서를 이용해 메시지 발행 가능

### 레디스

- 별도 스트림 생성 과정 X
- `XADD` 커맨드 사용하여 데이터 저장 시 저장과 동시에 스트림 생성 가능
    - 이미 존재하는 스트림인 경우 해당 스트림에 메시지 추가

## 데이터 조회

### 카프카

- 특정 토픽 실시간 리스닝
- 기본적으로는 리스닝을 시작한 시점부터 토픽에 새로 저장되는 메시지 반환받도록 동작
(`—from-beginning` 옵션 사용 시 처음부터 구독 가능)
- 소비자는 읽어올 데이터가 더 이상 없을 때 토픽에 들어올 때까지 토픽 리스닝

### 레디스

**실시간 데이터 조회**

```jsx
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```

- `BLOCK 0` 지정 시 데이터가 존재하지 않아도 리스닝
- ID로 `$` 지정 시 커맨드를 실행한 이후의 메 시지만을 구독, `0` 지정 시 처음부터 구독

**특정 데이터 조회**

```jsx
XRANGE key start end [COUNT count]
XREVRANGE key end start [COUNT count] -- 역순 조회
```

- ID를 이용해 원하는 시간대의 데이터 조회
    - `-` : 스트림 내 가장 작은 ID
    - `+` : 스트림 내 가장 마지막 ID
    - `(` : 해당 ID 미포함
- 커맨드 수행 시점에 스트림에 저장된 데이터 반환한 뒤 종료 (추가 리스닝 X)

## 소비자와 소비자 그룹

- `팬아웃` : 같은 데이터를 여러 소비자에게 전달하는 것

### 카프카

- 유니크 키가 파티션 내에서만 보장되어 여러 파티션에서 토픽 구독 시 데이터 순서 보장 X
- 메시지가 토픽에 저장될 때 파티션에 랜덤하게 분배되고, 소비자는 파티션의 존재를 알지 못하고 토픽 내의 전체 파티션에서 데이터를 읽어 옴
    - 여러 파티션 간 데이터 정렬은 보장되지 않아 결국 데이터 순서가 보장되지 않음
- 메시지 순서 보장이 필요할 경우 소비자 그룹 사용 필요

### 레디스

- `XREAD` 커맨드를 이용하여 팬아웃 사용 가능
- 데이터 저장 시 고유한 ID를 부여 받아 순서대로 저장되어 순서는 항상 보장

## 소비자 그룹

### 카프카

- 소비자 그룹에 여러 소비자 추가 가능, 소비자는 토픽 내 파티션과 일대일로 매핑
- 파티션 내부에서는 메시지의 순서가 보장되어 소비자는 데이터의 순서를 보장받을 수 있음

### 레디스

```jsx
XGROUP CREATE {stream} {groupName} $
//  $ : 현재 시점 이후의 데이터부터 리스닝

XREADGROUP GROUP {groupName} {consumerName} COUNT {count} STREAMS {stream ...} > 
// > : 다른 소비자에게 전달되지 않은 데이터 조회
```

- 레디스 스트림에서 소비자 그룹은 스트림의 상태를 나타내는 개념 ❓
- 소비자 그룹 내 소비자는 다른 소비자가 아직 읽지 않은 데이터만을 읽어감
- `XGROUP` 을 통하여 소비자 그룹 생성, `XREADGROUP`을 통하여 소비자 그룹에서 메시지 조회
- 소비자는 최초 언급 시 자동 생성되어 명시적으로 생성할 필요 X
- 여러 소비자 그룹이 같은 스트림을 구독할 수 있고 독립적으로 동작
    - EX) 그룹 1의 소비자가 A 메시지 구독 시 그룹 1에서는 더이상 조회할 수 없으나 그룹 2에서는 가능
- 하나의 소비자 그룹에서 여러 스트림 구독 가능
    
    ```jsx
    XGROUP CREATE EmaiL bigroup 0
    XGROUP CREATE Push bigroup 0
    
    XREADGROUP GROUP BIGroup BI1 COUNT 2 STREAMS Email Push > >
    ```
    

## ACK와 보류 리스트

- 소비자 그룹에 속한 소비자가 메시지를 읽어가면 읽어간 메시지에 대한 보류 리스트 생성, 마지막으로 읽어간 데이터의 ID로 `last_delivered_id` 값 업데이트
    - `last_delivered_id` : 마지막으로 전달한 ID가 무엇인지를 파악해 동일한 메시지를 중복으로 전달하지 않도록 함
- 소비자가 메시지 수신 후 스트림에게 데이터가 처리됐다는 뜻의 ACK를 보내면 해당 소비자의 보류 리스트에서 해당 메시지 삭제
    
    ⇒ 예상치 못한 서비스 중단 상황에서도 모든 메시지를 놓치지 않게 함
    

**보류 리스트 조회**

```json
XPENDING <key> <groupname> [<start-id> <end-id> <count> [<consumer-name>]
```

**ACK 전송**

```json
XACK <key> <groupname> <id>
```

### 메시지 보증 전략

- `at most once` : 메시지 최소 한 번 전송, 소비자는 실제 처리 전 ACK 선 전송
    - 빠른 응답이 우선인 경우 선택
- `at least once` : 소비자는 받은 메시지를 모두 처리한 뒤 ACK 전송
    - 메시지 처리 시 멱등성 보장 필요
- `exactly once` : 모든 메시지가 무조건 한 번씩 전송, 처리 여부 판단은 추가 구현 필요

## 메시지의 재할당

```jsx
XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2> ...
```

- 소비자 서버에 장애가 발생해 복구되지 않아 소비자가 처리 보류중인 메시지들은 다른 소비자가 처리 가능
- 보류 상태로 머무른 시간이 최소 대기 시간을 초과한 경우에만 메시지 소유권 변경 가능하도록 하여 다른 소비자에게 중복으로 할당되지 않도록 함
- `XCLAIM` 커맨드 실행 시 소유권 변경 대상 메시지들의 보류 시간이 즉시 0으로 변경되고, 이후 다른 소비자에서 동일 커맨드 실행 시 최소 대기 시간을 충족하지 않는 경우 커맨드가 무시됨

## 메시지의 자동 재할당

```jsx
XAUTOCLAIM <key> <group> <consumer> <min-idle-time> <start> [COUNT count] [JUSTID]
```

- `XCLAIM`을 이용한 잦은 소유권 재할당이 일어나는 경우 사용
- `XAUTOCLAIM` : 소비자가 직접 보류했던 메시지 중 하나를 자동으로 가져옴, 할당 대기 중인 다음 메시지 ID를 반환하여 반복적 호출 가능하게 함
    - 더 이상 대기 중인 보류 메시지가 없을 때 `0-0` 반환

## 메시지의 수동 재할당

- 스트림 내 각 메시지는 `counter` 값 존재
    - `XREADGROUP` , `XCLAIM` 커맨드를 이용해 소비자에게 메시지 할당 시 1씩 증가
- 메시지에 문제가 존재하여 처리되지 못하고 소비자에게 할당이 반복되어 카운터가 특정 값에 도달하면 메시지를 특수한 다른 스트림에 보내 고나리자가 추후 처리될 수 있도록 처리 필요
    - 이러한 메시지는 `DEAD LETTER`라고 불림

## 스트림 상태 확인

`XINFO` 명령어를 통하여 스트림의 여러 상태 확인 가능

- `XINFO HELP` : 사용 가능한 옵션 조회
- `XINFO consumers <stream key> <소비자 그룹명>` : 특정 소비자 그룹에 속한 소비자 정보 조회
- `XINFO GROUPS <stream key>` : 스트림에 속한 전체 소비자 그룹 리스트 조회
- `XINFO STREAM <stream key>` : 스트림 자체 정보 조회
